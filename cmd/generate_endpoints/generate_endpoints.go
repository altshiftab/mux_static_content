package main

import (
	"archive/zip"
	"bytes"
	"context"
	_ "embed"
	"flag"
	"fmt"
	motmedelContext "github.com/Motmedel/utils_go/pkg/context"
	motmedelUtilsEnv "github.com/Motmedel/utils_go/pkg/env"
	motmedelErrors "github.com/Motmedel/utils_go/pkg/errors"
	motmedelHttpContext "github.com/Motmedel/utils_go/pkg/http/context"
	motmedelHttpLog "github.com/Motmedel/utils_go/pkg/http/log"
	"github.com/Motmedel/utils_go/pkg/http/mux/types/endpoint_specification"
	"github.com/Motmedel/utils_go/pkg/http/mux/utils/generate"
	motmedelHttpUtils "github.com/Motmedel/utils_go/pkg/http/utils"
	motmedelLog "github.com/Motmedel/utils_go/pkg/log"
	motmedelContextLogger "github.com/Motmedel/utils_go/pkg/log/context_logger"
	errorLogger "github.com/Motmedel/utils_go/pkg/log/error_logger"
	"github.com/vphpersson/code_generation_go/pkg/code_generation"
	"log/slog"
	"net/http"
	"os"
	"reflect"
	"strings"
	"time"
)

const codeGeneratedString = "// Code generated by github.com/Motmedel/k_anonymity/cmd/generate_map; DO NOT EDIT.\n"

func main() {

	logger := errorLogger.Logger{
		Logger: motmedelContextLogger.New(
			slog.NewJSONHandler(os.Stderr, nil),
			&motmedelLog.ErrorContextExtractor{},
			&motmedelHttpLog.HttpContextExtractor{},
		),
	}
	slog.SetDefault(logger.Logger)

	var path string
	flag.StringVar(&path, "path", "", "path to generate code from")

	var packageName string
	flag.StringVar(
		&packageName,
		"package-name",
		motmedelUtilsEnv.GetEnvWithDefault("GOPACKAGE", "main"),
		"The name of the package in the output.",
	)

	var variableName string
	flag.StringVar(&variableName, "variable", "x", "The name of the variable in the output.")

	flag.Parse()

	if path == "" {
		logger.FatalWithExitingMessage("Empty path.", nil)
	}

	var specifications []*endpoint_specification.EndpointSpecification

	if strings.HasPrefix(path, "http://") || strings.HasPrefix(path, "https://") {
		ctxWithHttp := motmedelHttpContext.WithHttpContext(context.Background())
		httpClient := &http.Client{Timeout: 10 * time.Second}
		_, body, err := motmedelHttpUtils.Fetch(ctxWithHttp, path, httpClient, nil)
		if err != nil {
			logger.ErrorContext(
				motmedelContext.WithErrorContextValue(
					ctxWithHttp,
					motmedelErrors.New(fmt.Errorf("fetch: %w", err), path),
				),
				"An error occurred when fetching. Exiting.",
			)
			os.Exit(1)
		}

		bytesReader := bytes.NewReader(body)
		size := int64(len(body))
		zipReader, err := zip.NewReader(bytesReader, size)
		if err != nil {
			logger.FatalWithExitingMessage(
				"An error occurred when creating a zip reader. Does the body constitute a Zip file?",
				fmt.Errorf("zip new reader: %w", err),
				bytesReader, size,
			)
		}

		specifications, err = generate.EndpointSpecificationsFromZip(zipReader, true)
		if err != nil {
			logger.FatalWithExitingMessage(
				"An error occurred when creating endpoint specifications from a Zip.",
				fmt.Errorf("endpoint specifications from zip: %w", err),
				zipReader,
			)
		}
	} else {
		var err error
		specifications, err = generate.EndpointSpecificationsFromDirectory(path, true)
		if err != nil {
			logger.FatalWithExitingMessage(
				"An error occurred when creating endpoint specifications from a Zip.",
				fmt.Errorf("endpoint specifications from directory: %w", err),
				path,
			)
		}
	}

	literal, importSet, err := code_generation.GenerateLiteral(reflect.ValueOf(specifications), nil)
	if err != nil {
		logger.FatalWithExitingMessage(
			"An error occurred when generating the literal.",
			fmt.Errorf("generate literal: %w", err),
		)
	}
	output := fmt.Sprintf(
		"package %s\n%s\nvar %s = %s",
		packageName,
		importSet.Generate(),
		variableName,
		literal,
	)

	if gofile := os.Getenv("GOFILE"); gofile != "" {
		fileName := strings.TrimSuffix(gofile, ".go") + "_generated.go"
		data := []byte(codeGeneratedString + output)
		if err := os.WriteFile(fileName, data, 0600); err != nil {
			logger.FatalWithExitingMessage(
				"An error occurred when writing the file.",
				motmedelErrors.New(fmt.Errorf("os write file: %w", err), fileName, data),
			)
		}
	} else {
		fmt.Println(output)
	}
}
